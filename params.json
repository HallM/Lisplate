{
  "name": "Lisplate",
  "tagline": "Functional template engine based on Lisp-like syntax for JavaScript",
  "body": "# Lisplate template engine #\r\n\r\nLisplate is a Lisp-like template engine with a reference implementation for JavaScript.\r\n\r\n## Installing ##\r\n\r\nLisplate is available on NPM.\r\n```\r\nnpm install lisplate\r\n```\r\n\r\n## Getting Started ##\r\n\r\nOnce you have lisplate installed, you can require it in like any other module.\r\n\r\nLisplate does require a global Promise to be set up. Native ES6 promises are supported\r\nalong with any Promise polyfill or setting global.Promise to the implementation\r\nof your choice.\r\n\r\nLisplate exports a class to allow users to create different instances.\r\nEach instance may have different loaders, configuration, and run completely separate.\r\n\r\nIn order to load templates,\r\nLisplate requires a `sourceLoader` function to find and read the source to be compiled.\r\n\r\nLisplate also provides a hook to load view models for templates using the\r\n`viewModelLoader` function.\r\n\r\nBoth the `sourceLoader` and `viewModelLoader` may run synchronously or use a supplied callback.\r\nIn the examples below, the `sourceLoader` is used asynchronously with a callback\r\nwhile the `viewModelLoad` is used synchronously.\r\n\r\n```\r\nvar Lisplate = require('lisplate');\r\nvar engine = new Lisplate({\r\n    sourceLoader: function(name, callback) {\r\n        var filepath = path.resolve(myViewDirectory, name + '.ltml');\r\n        fs.readFile(filepath, 'UTF-8', callback);\r\n    },\r\n    viewModelLoader: function(templateName) {\r\n        var filepath = path.resolve(myViewModelDirectory, templatePath + '.js');\r\n        var viewmodel = null;\r\n        try {\r\n            viewmodel = require(filepath);\r\n        } catch(e) {\r\n        }\r\n        return viewmodel;\r\n    }\r\n});\r\n```\r\n\r\n## Lisplate Instance API ##\r\n\r\n### function addHelper(name, fn) ###\r\nAdds the function `fn` to the helpers context identified by `name`.\r\n\r\n### function loadTemplate(templateName, [callback]) ###\r\nLoads a template and returns a function that can be executed by `render`.\r\nIf the template is not cached, `loadTemplate` will use your `sourceLoader` to\r\nload the source to be compiled.\r\nThis will use the compileFn function internally and cache the result.\r\nReturns a Promise that returns the renderable function.\r\nIf a callback is passed, the callback will be used instead.\r\n\r\n### function compileFn(templateName, src, [callback]) ###\r\nCompiles the `src` using `compile` and caches the result under `templateName`.\r\nReturns a Promise that returns the renderable function.\r\nIf a callback is passed, the callback will be used instead.\r\n\r\n### function compile(templateName, src) ###\r\nCompiles the `src`, attempts to load the view model class using `viewModelLoader`\r\nand returns a function that can be passed to `render`.\r\n\r\n### function render(template, data, [callback]) ###\r\nRenders a template from the `template` function.\r\nMay return a string or a Promise if the template requires asynchronous handling.\r\nIf a callback is passed, the callback will be used instead.\r\n\r\n### function renderTemplate(templateName, data, [callback]) ###\r\nSimilar to `render`, but accepts a `templateName` to determine which template to load\r\nand render. If `templateName` is a function, the function is used as the template function\r\npassed to `render`. The output is the same as the `render` function.\r\n\r\n## Syntax ##\r\n\r\n## Blocks ##\r\n\r\nBlocks are special regions which can contain free-form HTML with expressions scattered throughout.\r\nEvery template starts with a Block, so you can get to adding HTML without any boilerplate.\r\nWithin an expression, only the create function expression may contain a Block.\r\n\r\n## Expressions ##\r\n\r\nExpressions in Lisplate are surrounded by `{}`.\r\nThe main expression type is the function call.\r\nThere are other expressions such as:\r\n\r\n### Literals ###\r\n\r\nLisplate supports the string and number literals\r\n\r\nStrings are surrounded by double quotes\r\n```\r\n\"a string\"\r\n```\r\n\r\nNumbers may be integers or decimal numbers.\r\n```\r\n42\r\n6.28\r\n```\r\n\r\nBoolean values may be true or false.\r\n```\r\ntrue\r\nfalse\r\n```\r\n\r\n### Empty Expression ###\r\n\r\nThe empty expression is mostly used for passing `null`-like values for parameters.\r\n\r\n```\r\n{}\r\n```\r\n\r\n## Arrays ##\r\n\r\nThe array expression allows creation of standard arrays.\r\nArrays may contain anything using expressions.\r\nUnlike JavaScript arrays, Lisplate arrays are separated by spaces\r\nsimilar to function parameters.\r\n\r\n```\r\n(itemOne itemTwo {+ 3 5} {fn (a b) {- a b}})\r\n()\r\n```\r\n\r\n## Associative Arrays / Maps ##\r\n\r\nAssociative arrays expression creates a key to value map.\r\nThe values can be from any expression.\r\nAssociative arrays are essentially a JavaScript object internally.\r\nUnlike JavaScript objects, Lisplate associative arrays look similar to arrays,\r\nbut use `:key value` with spaces separating the key:value pairs.\r\nThe syntax is similar to Clojure, but using `()` instead of `{}`.\r\n\r\n```\r\n(:key value :two {+ 3 5} :myfn {fn (a b) {- a b}})\r\n```\r\n\r\n### Raw ###\r\n\r\nRaw expressions print out text without any processing.\r\n\r\n```\r\n{` raw text `}\r\n```\r\n\r\n### Calling Functions ###\r\n\r\nThe primary expression in Lisplate is the function call.\r\nWhere most languages use filters, helpers, and other constructs, Lisplate only needs functions.\r\nThe only exception is printing a variable, which is a special case.\r\n\r\nFunction calls start with the function to be called, either by identifier or an anonymous function.\r\nFunctions can have any number of parameters separated by spaces.\r\n```\r\n{myFunction valueOne valueTwo}\r\n{{fn (param1 param2)\r\nCalling an anonymous functions\r\n} value1 value2}\r\n```\r\n\r\n#### Print variable ###\r\n\r\nAs printing variables is very common in a template language, Lisplate makes them easier.\r\nPrinting a variable is much like a function call with no parameters.\r\nLisplate will check if the variable is a function to be called or just output the variable.\r\n\r\n```\r\n{myValue}\r\n{noParamFunction}\r\n```\r\n\r\nBy default, printing the contexts of a variable will be escaped per the HTML escape function.\r\nTo disable automatic escaping, use a `!` before the identifier to print the contents as is.\r\n\r\n```\r\n{!myRawContents}\r\n{!myFunction value}\r\n```\r\n\r\nThe automatic escaping only occurs for externally-defined functions.\r\nBuilt-in functions do not escape their output nor do any functions defined in the template.\r\n\r\n#### Built-in functions ####\r\n\r\nLisplate provides a number of built-in functions.\r\n\r\n##### Math #####\r\n\r\nThe standard math operators are available:\r\n`+`, `-`, `*`, `/`, `%`\r\n\r\n##### Comparisons #####\r\n\r\nThe standard comparison operators are available:\r\n`==`, `!=`, `<`, `>`, `<=`, `>=`\r\n\r\nThe one exception is for the `not`, `and`, and `or`\r\nuse the full work instead of the symbol notation.\r\n\r\n##### if #####\r\n\r\nThe if built-in allows for conditional sections.\r\nWhen the condition is truthy, the ThenExpression is executed.\r\nOtherwise, the ElseExpression is executed.\r\nA note with JavaScript: empty array is a truthy value. In these cases,\r\nuse the `isEmpty` or `isNotEmpty` built-ins along with the `if`.\r\n\r\nThe ElseExpression is optional, but the ThenExpression is required.\r\nTo use only an ElseExpression, define the ThenExpression to be an Empty, `{}`\r\n\r\nAny expression may be used in either the ThenExpression or ElseExpression.\r\nIf a function is used for either expression, no parameter is passed to the call.\r\n\r\n```\r\n{if Condition ThenExpression ElseExpression}\r\n\r\n{if myValue \"It is true!\" \"It is not true}\r\n```\r\n\r\n##### each #####\r\n\r\nThe each built-in loops over an array.\r\nThe ThenExpression is executed for each item within the array.\r\nIf the array is falsey or empty, an ElseExpression may be used.\r\n\r\nThe ElseExpression is optional, but the ThenExpression is required.\r\nTo use only an ElseExpression, define the ThenExpression to be an Empty, `{}`\r\n\r\nAny expression may be used in either the ThenExpression or ElseExpression.\r\nIf a function is used for the ThenExpression, two parameters will be passed.\r\nThe first parameter is the current item within the array.\r\nThe second parameter is the index of the item in the array.\r\nif a function is used for the ElseExpression, no parameter is passed to the call.\r\n\r\n```\r\n{each Identifier ThenExpression ElseExpression}\r\n\r\n{each myArray {fn (item index)\r\nItem is: {item}\r\nIndex of the item is: {index}\r\n} \"There are no items in the array\"}\r\n```\r\n\r\n##### isEmpty and isNotEmpty #####\r\n\r\nThe two functions `isEmpty` and `isNotEmpty` provide helpers to determine\r\nif an item is considered empty. Strings and arrays are considered empty\r\nwhen their length is 0. The number 0 is also empty.\r\nAll falsy value (false, null, undefined) are also considered empty.\r\nAll other values are considered not-empty;\r\n\r\n##### include #####\r\n\r\nThe include built-in includes another template.\r\nParameters passed to the include call will be passed to the template.\r\n\r\n```\r\n{include string values...}\r\n\r\n{include \"my-other-template\" valueOne valueTwo}\r\n```\r\n\r\n##### Binary Operators: Math and Comparisons #####\r\n\r\nBinary operators are used in a prefix notation similar to Lisp.\r\nLisplate does not use order of operations.\r\nThe order must be defined within each operator call.\r\n\r\n```\r\n{+ 3 4}\r\n7\r\n\r\n{< {- 4 3} {* {+ 5 2} 7}\r\ntrue (1 < 49)\r\n```\r\n\r\nSupported operators:\r\n* `*`\r\n* `/`\r\n* `%`\r\n* `+`\r\n* `-`\r\n\r\n* `==`\r\n* `!=`\r\n* `<`\r\n* `>`\r\n* `>=`\r\n* `<=`\r\n\r\n### Contexts ###\r\n\r\nContexts are special variables that provide access to template parameters and view models.\r\nContexts can be used to access variables even if the variable name is used as a parameter.\r\nTo select a context for an identifier, put the context label and a colon before the identifier.\r\nContexts and fields on a context are protected and can not be overriden by internal scopes.\r\n```\r\nContext:Identifier\r\n```\r\n```\r\n{data:myParameter}\r\n{helper:myHelper}\r\n{viewmodel:myViewModelItem}\r\n{strings:someString}\r\n{each data:myArray {fn (myItem)\r\n  This is the array item: {myItem}\r\n  This is the data item: {data:myItem}\r\n}}\r\n```\r\n\r\nBuilt in functions are on the `runtime` context, but are accessible without a context specifier.\r\n\r\nAdded helper functions are in the `helper` context.\r\n\r\nData sent to the template via an include or through rendering is in the `data` context.\r\n\r\nView model fields are accessible in the `viewmodel` context.\r\n\r\nFields in the strings file are accessible in the `strings` context.\r\n\r\n**Coming soon**: Currently Lisplate does not search contexts.\r\nBefore 1.0, a template should be capable of searching contexts (parameters and viewmodel).\r\nSpecifying a context will avoid the search and may be faster.\r\n\r\n### Creating Functions ###\r\n\r\nAnonymous functions can be created using the `fn` function.\r\nCreating a function is the only way to create a Block outside of the starting Block.\r\nAnonymous functions may be passed as a parameter or called directly.\r\n\r\nEach function creates a new scope containing it's parameters.\r\nThe function also has access to the scope containing the function,\r\nbut does not have access to the scope calling the function.\r\n\r\nThe parameter specification is surrounded by `()` and is optional.\r\nEach parameter name is separated by a space.\r\n\r\n```\r\n{fn (paramOne paramTwo)\r\nThis is now a block\r\n<div>Free HTML is allowed here</div>\r\n{paramOne} {paramTwo}\r\n}\r\n```\r\n\r\n## Advanced Tips ##\r\n\r\n### Defining variables ###\r\n\r\nMuch like Lisp and other functional langauges, local variables can be created using functions.\r\n\r\n```\r\n{{fn (newVariable)\r\nWe created the variable: {newVariable}\r\n} \"This is the value of the variable\"}\r\n```\r\n\r\nThe variable creation and scope rules can be used to reference the\r\nsurrounding scope.\r\n\r\n```\r\n{{fn (liTag liClass renderColors)\r\n    <div>\r\n        {renderColors data:colors {fn (color)\r\n            <{liTag}\r\n              {if liClass {+ {+ \"class=\\\"\" liClass} \"\\\"\"}}\r\n              style=\"background-color: {color}\">\r\n            {color}\r\n            </{liTag}>\r\n        }}\r\n    </div>\r\n}\r\n    \"li\"\r\n    \"color\"\r\n    {fn (colors renderColor)\r\n        {if colors.length {fn\r\n            <ul>{each colors renderColor}</ul>\r\n        } {fn\r\n            <div>No colors!</div>\r\n        }}\r\n   }\r\n}\r\n```",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}