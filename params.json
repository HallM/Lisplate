{
  "name": "Lisplate",
  "tagline": "Functional template engine based on Lisp-like syntax for JavaScript",
  "body": "# Lisplate template engine #\r\n\r\n[![npm version](https://badge.fury.io/js/lisplate.svg)](https://badge.fury.io/js/lisplate)\r\n[![Build Status](https://travis-ci.org/lisplate/lisplate.svg?branch=master)](https://travis-ci.org/lisplate/lisplate)\r\n[![Coverage Status](https://coveralls.io/repos/github/lisplate/lisplate/badge.svg?branch=master)](https://coveralls.io/github/lisplate/lisplate?branch=master)\r\n\r\nLisplate is a Lisp-like template engine with a reference implementation for JavaScript.\r\n\r\n## Installing ##\r\n\r\nLisplate is available on NPM.\r\n```\r\nnpm install lisplate\r\n```\r\n\r\n## Getting Started ##\r\n\r\nOnce you have lisplate installed, you can require it in like any other module.\r\n\r\nFor the browser side, Lisplate provides lisplate-core and lisplate-full bundles.\r\nThe lisplate-core bundle includes only the core and does not include the\r\ncompiler. The lisplate-full bundle includes the compiler as well as the core.\r\n\r\nLisplate does require a global Promise to be set up. Native ES6 promises are supported\r\nalong with any Promise polyfill or setting global.Promise to the implementation\r\nof your choice.\r\n\r\nLisplate exports a class to allow users to create different instances.\r\nEach instance may have different loaders, configuration, and run completely separate.\r\n\r\nIn order to load templates,\r\nLisplate requires a `sourceLoader` function to find and read the source to be compiled.\r\n\r\nLisplate also provides hooks to load view models for templates using the\r\n`viewModelLoader` function and strings using the `stringsLoader`.\r\n\r\nEach of the three hook points take only one parameter, the `templateName`.\r\nThe `templateName` is the same that is passed to `loadTemplate`, `renderTemplate`,\r\nor as the key to the cache.\r\n\r\nThe `sourceLoader` and `viewModelLoader` may use Promises, run synchronously,\r\nor use a supplied callback. If the hook takes a second argument, it is assumed\r\nto be asynchronous with a callback.\r\n\r\nIn the examples below, the `sourceLoader` is used asynchronously with a callback,\r\nthe `viewModelLoad` is used synchronously,\r\nand the `stringsLoader` is used as a Promise.\r\n\r\n```\r\nvar Lisplate = require('lisplate');\r\nvar engine = new Lisplate({\r\n    sourceLoader: function(name, callback) {\r\n        var filepath = path.resolve(myViewDirectory, name + '.ltml');\r\n        fs.readFile(filepath, 'UTF-8', callback);\r\n    },\r\n    viewModelLoader: function(templateName) {\r\n        var filepath = path.resolve(myViewModelDirectory, templatePath + '.js');\r\n        var viewmodel = null;\r\n        try {\r\n            viewmodel = require(filepath);\r\n        } catch(e) {\r\n        }\r\n        return viewmodel;\r\n    },\r\n    stringsLoader: function(templateName) {\r\n        var readFileAsync = Bluebird.promisify(fs.readFile);\r\n\r\n        var filepath = path.resolve(myStringDirectory, templatePath + '.json');\r\n        return readFileAsync(filepath, 'UTF-8').then(JSON.parse);\r\n    }\r\n});\r\n```\r\n\r\n## Compiling ahead of time ##\r\n\r\nThe compiler can be used to compile templates ahead of time into UMD modules.\r\nThese modules support AMD and CommonJS loaders as well as being included\r\nin browser script tags.\r\n\r\n## Lisplate Instance API ##\r\n\r\n### function addHelper(name, fn) ###\r\nAdds the function `fn` to the helpers context identified by `name`.\r\n\r\n### function loadTemplate(templateInfo, [callback]) ###\r\nLoads a template by name or a pre-compiled template.\r\n\r\n`templateInfo` may be an object with a `templateName` string and a\r\n`render` factory function. if the `render` function is missing\r\nand only a `templateName` exists, the `loadTemplate` will work as if\r\n`templateInfo` was a string (see below).\r\n\r\n`templateInfo` may be a string for the name of the template that will\r\nbe loaded with the `sourceLoader` and compiled into a render factory.\r\n\r\nOnce the render factory is loaded, the `viewModelLoader` is called\r\nif one exists. The render factory is used to generate the final renderable.\r\nThe final renderable is cached using the `templateName` as the key.\r\n\r\nThis function returns a promise which returns the renderable.\r\nThe renderable can be passed to `render`.\r\nIn most cases, you will want to use `renderTemplate` and pass a `templateName`.\r\n\r\nIf a callback is passed, the callback is used to return instead of returning\r\na promise.\r\n\r\n### function render(template, data, [callback]) ###\r\nRenders a template from the `template` function.\r\nMay return a string or a Promise if the template requires asynchronous handling.\r\nIf a callback is passed, the callback will be used instead.\r\n\r\n### function renderTemplate(templateName, data, [callback]) ###\r\nSimilar to `render`, but accepts a `templateName` to determine which template to load\r\nand render. If `templateName` is a function, the function is used as the template function\r\npassed to `render`. The output is the same as the `render` function.\r\n\r\n## Lisplate.Compiler ##\r\n\r\n### function compile(templateName, src) ###\r\nCompiles the `src` and returns a render-factory function that can be passed to `loadTemplate`.\r\nThe compiled code must be loaded before the template can be rendered.\r\n\r\n### function compileMpdule(templateName, src) ###\r\nRuns the `compile` function and returns a UMD wrapped template.\r\n\r\n\r\n## Syntax ##\r\n\r\n## Blocks ##\r\n\r\nBlocks are special regions which can contain free-form HTML with expressions scattered throughout.\r\nEvery template starts with a Block, so you can get to adding HTML without any boilerplate.\r\nWithin an expression, only the create function expression may contain a Block.\r\n\r\n## Expressions ##\r\n\r\nExpressions in Lisplate are surrounded by `{}`.\r\nThe main expression type is the function call.\r\nThere are other expressions such as:\r\n\r\n### Literals ###\r\n\r\nLisplate supports the string and number literals\r\n\r\nStrings are surrounded by double quotes\r\n```\r\n\"a string\"\r\n```\r\n\r\nNumbers may be integers or decimal numbers.\r\n```\r\n42\r\n6.28\r\n```\r\n\r\nBoolean values may be true or false.\r\n```\r\ntrue\r\nfalse\r\n```\r\n\r\n### Empty Expression ###\r\n\r\nThe empty expression is mostly used for passing `null`-like values for parameters.\r\n\r\n```\r\n{}\r\n```\r\n\r\n### Comments ###\r\n\r\nComments can be anywhere in code and are surrounded by `{*` and `*}`\r\n\r\n```\r\n{* comment *}\r\n{myfunction {* call with empty as parameter *} {}}\r\n```\r\n\r\n### Arrays ###\r\n\r\nThe array expression allows creation of standard arrays.\r\nArrays may contain anything using expressions.\r\nUnlike JavaScript arrays, Lisplate arrays are separated by spaces\r\nsimilar to function parameters.\r\n\r\n```\r\n(itemOne itemTwo {+ 3 5} {fn (a b) {- a b}})\r\n()\r\n```\r\n\r\n### Associative Arrays / Maps ###\r\n\r\nAssociative arrays expression creates a key to value map.\r\nThe values can be from any expression.\r\nAssociative arrays are essentially a JavaScript object internally.\r\nUnlike JavaScript objects, Lisplate associative arrays look similar to arrays,\r\nbut use `:key value` with spaces separating the key:value pairs.\r\nThe syntax is similar to Clojure, but using `()` instead of `{}`.\r\n\r\n```\r\n(:key value :two {+ 3 5} :myfn {fn (a b) {- a b}})\r\n(:)\r\n```\r\n\r\n### Dynamic Key Lookup ###\r\n\r\nLooking up a value using a key on an associative array or a normal array uses `get`.\r\n```\r\n{get myArray 0}\r\n{get myArray index}\r\n{get myObject \"myKey\"}\r\n{get myObject dynamicKey}\r\n```\r\n\r\n`get` can also be used without a key to return the value of something.\r\n```\r\n{get myValue}\r\n```\r\n\r\n### Raw ###\r\n\r\nRaw expressions print out text without any processing.\r\n\r\n```\r\n{` raw text `}\r\n```\r\n\r\n### Calling Functions ###\r\n\r\nThe primary expression in Lisplate is the function call.\r\nWhere most languages use filters, helpers, and other constructs, Lisplate only needs functions.\r\nThe only exception is printing a variable, which is a special case.\r\n\r\nFunction calls start with the function to be called, either by identifier or an anonymous function.\r\nFunctions can have any number of parameters separated by spaces.\r\n```\r\n{myFunction valueOne valueTwo}\r\n{{fn (param1 param2)\r\nCalling an anonymous functions\r\n} value1 value2}\r\n```\r\n\r\n#### Print variable ###\r\n\r\nAs printing variables is very common in a template language, Lisplate makes them easier.\r\nPrinting a variable is much like a function call with no parameters.\r\nLisplate will check if the variable is a function to be called or just output the variable.\r\n\r\n```\r\n{myValue}\r\n{noParamFunction}\r\n```\r\n\r\nBy default, printing the contents of a variable will be escaped per the HTML escape function.\r\nTo disable automatic escaping, use a `safe` function before the identifier to print the contents as is.\r\n\r\n```\r\n{safe myRawContents}\r\n{safe {myFunction value}}\r\n```\r\n\r\nThe automatic escaping only occurs for externally-defined variables and functions.\r\nBuilt-in functions do not escape their output nor do any functions defined in the template.\r\n\r\nThe available escape functions are `escapeHtml`, `escapeJs`, and `escapeJson`.\r\nThese may be called in the code at any time and compiled.\r\nCalling one, such as `escapeJs` will not cause the `escapeHtml` to be called.\r\nDeclaring anything as \"safe\" will negate any later escapes.\r\n\r\n```\r\n{escapeHtml someHtml}\r\n{escapeJs someJs}\r\n{escapeJson someJson}\r\n\r\n{escapeHtml {safe doesNotGetEscaped}}}\r\n```\r\n\r\n#### Built-in functions ####\r\n\r\nLisplate provides a number of built-in functions.\r\n\r\n##### Binary Operators: Math and Comparisons #####\r\n\r\nBinary operators are used in a prefix notation similar to Lisp.\r\nLisplate does not use order of operations.\r\nThe order must be defined within each operator call.\r\n\r\n```\r\n{+ 3 4}\r\n7\r\n\r\n{< {- 4 3} {* {+ 5 2} 7}\r\ntrue (1 < 49)\r\n```\r\n\r\n##### Math #####\r\n\r\nThe standard math operators are available:\r\n\r\n`+`, `-`, `*`, `/`, `%`\r\n\r\nEach can also be called by the internal names, which the operators are aliases for:\r\n\r\n`add`, `sub`, `mul`, `div`, `mod`\r\n\r\n##### Comparisons #####\r\n\r\nThe standard comparison operators are available:\r\n\r\n`==`, `!=`, `<`, `>`, `<=`, `>=`\r\n\r\nEach can also be called by the internal names, which the operators are aliases for:\r\n\r\n`eq`, `neq`, `lt`, `gt`, `lte`, `gte`\r\n\r\nThe one exception is for the `not`, `and`, and `or`\r\nuse the full word instead of the symbol notation.\r\n\r\n##### if #####\r\n\r\nThe if built-in allows for conditional sections.\r\nWhen the condition is truthy, the ThenExpression is executed.\r\nOtherwise, the ElseExpression is executed.\r\nA note with JavaScript: empty array is a truthy value. In these cases,\r\nuse the `isEmpty` or `isNotEmpty` built-ins along with the `if`.\r\n\r\nThe ElseExpression is optional, but the ThenExpression is required.\r\nTo use only an ElseExpression, define the ThenExpression to be an Empty, `{}`\r\n\r\nAny expression may be used in either the ThenExpression or ElseExpression.\r\nIf a function is used for either expression, no parameter is passed to the call.\r\n\r\n```\r\n{if Condition ThenExpression ElseExpression}\r\n\r\n{if myValue \"It is true!\" \"It is not true}\r\n```\r\n\r\n##### each #####\r\n\r\nThe each built-in loops over an array.\r\nThe ThenExpression is executed for each item within the array.\r\nIf the array is falsey or empty, an ElseExpression may be used.\r\n\r\nThe ElseExpression is optional, but the ThenExpression is required.\r\nTo use only an ElseExpression, define the ThenExpression to be an Empty, `{}`\r\n\r\nAny expression may be used in either the ThenExpression or ElseExpression.\r\nIf a function is used for the ThenExpression, two parameters will be passed.\r\nThe first parameter is the current item within the array.\r\nThe second parameter is the index of the item in the array.\r\nif a function is used for the ElseExpression, no parameter is passed to the call.\r\n\r\n```\r\n{each Identifier ThenExpression ElseExpression}\r\n\r\n{each myArray {fn (item index)\r\nItem is: {item}\r\nIndex of the item is: {index}\r\n} \"There are no items in the array\"}\r\n```\r\n\r\n##### isEmpty and isNotEmpty #####\r\n\r\nThe two functions `isEmpty` and `isNotEmpty` provide helpers to determine\r\nif an item is considered empty. Strings and arrays are considered empty\r\nwhen their length is 0. The number 0 is also empty.\r\nAll falsy value (false, null, undefined) are also considered empty.\r\nAll other values are considered not-empty;\r\n\r\n##### include #####\r\n\r\nThe include built-in includes another template.\r\nParameters passed to the include call will be passed to the template.\r\n\r\n```\r\n{include string values...}\r\n\r\n{include \"my-other-template\" valueOne valueTwo}\r\n```\r\n\r\n### Namespaces ###\r\n\r\nNamespaces are special variables that provide access to template parameters and view models.\r\nNamespaces can be used to access variables even if the variable name is used as a parameter.\r\nTo select a namespace for an identifier, put the namespace label and a colon before the identifier.\r\nNamespaces and fields on a namespace are protected and can not be overriden by internal scopes.\r\n```\r\nNamespace::Identifier\r\n```\r\n```\r\n{data::myParameter}\r\n{helper::myHelper}\r\n{viewmodel::myViewModelItem}\r\n{strings::someString}\r\n{each data::myArray {fn (myItem)\r\n  This is the array item: {myItem}\r\n  This is the data item: {data::myItem}\r\n}}\r\n```\r\n\r\nBuilt in functions are on the `runtime` namespace, but are accessible without a namespace specifier.\r\n\r\nAdded helper functions are in the `helper` namespace.\r\n\r\nData sent to the template via an include or through rendering is in the `data` namespace.\r\n\r\nView model fields are accessible in the `viewmodel` namespace.\r\n\r\nFields in the strings file are accessible in the `strings` namespace.\r\n\r\nNot specifying a namespace will perform the following searches attempting to locate the identifier:\r\n\r\n1. an internal function?\r\n2. declared as a parameter to a parent block/function?\r\n3. perform a search in the following order:\r\n   1. viewmodel\r\n   2. data\r\n   3. helpers\r\n   4. strings\r\n   5. render-context\r\n\r\n### Creating Functions ###\r\n\r\nAnonymous functions can be created using the `fn` function.\r\nCreating a function is the only way to create a Block outside of the starting Block.\r\nAnonymous functions may be passed as a parameter or called directly.\r\n\r\nEach function creates a new scope containing it's parameters.\r\nThe function also has access to the scope containing the function,\r\nbut does not have access to the scope calling the function.\r\n\r\nThe parameter specification is surrounded by `()` and is optional.\r\nEach parameter name is separated by a space.\r\n\r\n```\r\n{fn (paramOne paramTwo)\r\nThis is now a block\r\n<div>Free HTML is allowed here</div>\r\n{paramOne} {paramTwo}\r\n}\r\n```\r\n\r\n## Issues to watch for ##\r\n\r\n### Parameters are not called automatically ###\r\n\r\nPassing a function as a parameter does not resolve the return value immediate.\r\nThe function itself is passed as a parameter.\r\nIn order to call the function immediately, wrap it as an explicit function call.\r\n```\r\n{myFn1 {myfn2 fn2p1} fn1p2}\r\n```\r\n\r\n### this and Binding ###\r\n\r\nLisplate will use proper bindings to maintain `this` when making a function call.\r\nThe following two examples will call with the generally expected `this` context.\r\n```\r\n{myObject.aFunction}\r\n{myObject.someFunction some parameters}\r\n```\r\n\r\nWhen passing a function as a parameter, the `this` context will be lost.\r\nThis is the same behavior as in normal JavaScript. The same workarounds apply here.\r\nThe most common occurances revolve around the `if` and `each`, which usually\r\nexpect functions to be passed in to execute.\r\n```\r\n{if myValue myObject.myFnCall} {* \"this\" context will not be the expected one *}\r\n```\r\n\r\n1. Pre-bind the function in your data or viewmodel before passing into Lisplate\r\n3. Wrap in a block to preserve auto-binding behavior\r\n   ```\r\n   {if myValue {fn\r\n     {myObject.myFnCall} {* proper binding is maintained here *}\r\n   }}\r\n   ```\r\n\r\n## Advanced Tips ##\r\n\r\n### Defining variables ###\r\n\r\nMuch like Lisp and other functional langauges, local variables can be created using functions.\r\n\r\n```\r\n{{fn (newVariable)\r\nWe created the variable: {newVariable}\r\n} \"This is the value of the variable\"}\r\n```\r\n\r\nThe variable creation and scope rules can be used to reference the\r\nsurrounding scope.\r\n\r\n```\r\n{{fn (liTag liClass renderColors)\r\n    <div>\r\n        {renderColors data:colors {fn (color)\r\n            <{liTag}\r\n              {if liClass {+ {+ \"class=\\\"\" liClass} \"\\\"\"}}\r\n              style=\"background-color: {color}\">\r\n            {color}\r\n            </{liTag}>\r\n        }}\r\n    </div>\r\n}\r\n    \"li\"\r\n    \"color\"\r\n    {fn (colors renderColor)\r\n        {if colors.length {fn\r\n            <ul>{each colors renderColor}</ul>\r\n        } {fn\r\n            <div>No colors!</div>\r\n        }}\r\n   }\r\n}\r\n```\r\n",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}